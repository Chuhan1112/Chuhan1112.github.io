# Welcome to Chuhan's Pages

### This is my github pages

***test***
## Yacc is Not Dead

​	最近，马修·梅(Matthew may)和大卫·达莱斯(David Darais)在arXiv网站上发表了一篇题为《Yacc已死》(Yacc is dead)的论文，在互联网上引起了热议。不幸的是，很多讨论似乎都集中在人们是否认为yacc已经或应该灭亡，而不是论文的技术价值上。

​	至少在这次事件中，有关yacc死亡的报道被严重夸大了。本文首先反对“货物崇拜解析”，即==通过复制和粘贴来自其他来源的正则表达式来将解析器放在一起，直到它们工作为止==。不幸的是，这篇论文最终成为了一种更糟糕的货运崇拜的一个例子：在没有任何真正理论基础的情况下，声称自己有理论基础。这是一种非常强烈的批评，但我认为这很重要，因为<u>该论文重复了导致广泛的指数时间正则表达式匹配的错误</u>。我将在这篇文章的其余部分解释我的意思。但要做到这一点，我们必须首先回顾一些历史。

Grep和yacc是来自Unix的两个良好理论的规范示例——正则表达式和LR解析，它们产生有用的软件工具。 良好的理论部分很重要，这也是yacc没死的原因。

### 正则表达式

​	第一篇关于处理正则表达式的开创性论文是Janus Brzozowski 1964年的CACM文章“正则表达式的衍生”。这个公式是Ken Thompson聪明的动态正则表达式编译器的基础，他在1968年的CACM文章“正则表达式搜索算法”中描述了这个编译器。汤普森在加州大学伯克利分校读书时，他从布佐佐斯基那里学到了正则表达式。后来，阿霍和乌尔曼在各自的教科书中都介绍了汤普森的论文现在作为标准的框架，即NFA结构和添加缓存状态以生成DFA。

​	不过，1964年的理论比1968年的论文更能说明问题。特别是，因为Thompson的代码计算的每个状态都是短暂的——它只在处理单个字节时持续——所以没有必要应用Brzozowski的论文中包含的更激进的转换，比如将 `x|x` 改写成`x`。

​	Owens、Reppy和Turon最近发表了一篇题为==“正则表达式衍生物的重新审视”(Regular-expression derivatives reexamined)==的论文，该论文回到了最初的Brzozowski论文，并==考虑了在缓存状态的正则表达式引擎中使用Brzozowski简化规则的效果==(教科书称之为`DFA`)。在这里，简化有一个重要的好处，那就是减少了不同状态的数量，因此像lex这样的lexer生成器或像grep这样的正则表达式匹配器可以减少给定模式所需的内存占用。由于实现以符号形式操作正则表达式，而不是通常的图形节点集，因此在大多数函数式编程语言中，正则表达式都是非常自然的表达式。所以它更有效，更容易实现:双赢。

### Yacc is dead?

​	似乎有点离题，但它与“Yacc已死”的论文相关。这篇论文的灵感来自于“正则表达式衍生物的重新审视”的论文，它表明，==既然您可以定义上下文无关文法的衍生形式，那么您可以将上下文无关文法的框架定为采用连续衍生形式==。正如NFA的每个输入转换可以被描述为——采用与原始NFA状态相对应的正则表达式的衍生形式（相对于输入字符）一样，每个转变过渡的 LR(0) 分析表可以被描述为——采用对应于原始LR（0）状态的语法导数（相对于移位符号）。然而，一个关键的区别是==NFA 状态通常不带任何状态，可以删除重复项，而解析器与每个LR(0)解析状态关联一个解析堆栈，这使得删除重复项更加复杂。==

### 线性vs指数运行时

​	正则表达式匹配的线性时间保证是由于这样一个事实，即由于您可以在处理过程中消除重复的状态，所以必须在输入的任意点上考虑 NFA 状态的数量是有限的。如果不能消除重复的LR(0)状态，就不存在这样的边界，也不存在这样的线性时间保证。

​	Yacc和其他解析器生成器==通过要求解析状态自动机不存一点二义性==来保证线性时间：在必须探索多个可能的下一个状态的情况下，绝不能存在(状态、输入符号)组合。在yacc中，这些可能的==二义性==被称为`移入/规约`或`规约/规约`冲突。毫无疑问，编写没有二义性的yacc语法的技巧是不可思议的，尤其是在yacc很难解释出错部位的情况下，但这并不是该方法固有的。当您设法写出一个没有这些冲突的语法时，yacc会给您两个重要的保证：

* 首先，您定义的语言是明确(unambiguous)的。没有可以用多种方式解释的输入。
* 其次，即使语法上无效，生成的解析器也会按时间长度线性解析您的输入文件。 如果你要定义一种编程语言，这些都是非常重要的属性。

​	“Yacc已死”一文中概述的方法放弃了这两个特性。你提供给解析器的语法可以是有二义性的的。如果是这样，它可能需要成倍地考虑许多解析：它们可能全部成功，也可能全部失败，或者可能除了最后一个之外全部失败。这意味着最坏情况下的运行时间是输入长度的指数级。这篇论文提出了一些关于延迟返回解析的声明，即如果一个程序只关心第一个或两个，它就不会支付计算所有其他的成本。这很好，但是如果没有成功的解析，延迟就没有帮助。

很容易构建一个需要指数时间拒绝一个输入的例子。考虑这个一元和的语法:

```
S → T
T → T + T | N
N → 1
```

​	这个语法是有二义性的:它并没有说是否应该解析为`1 + 1 + 1(1 + 1)+ 1`或`1 + (1 + 1)`。更糟糕的是，作为输入变长指数有许多可能的解析,大约是 $O(3^n)$。如果特定的选择并不重要，那么对于一个格式良好的输入你可以用第一个解析，不管它是什么，然后停止，而不会在其他时间上浪费任何时间。 但是假设输入有语法错误，就像`1 + 1 + 1 +…+ 1 + 1 + 1 ++ 1`。回溯解析器将尝试对长的初始前缀进行所有可能的解析，以防其中一个可以跟着错误的`++1`。因此，当用户输入错误，程序嘎然而止。

​	对于不涉及无效输入的示例，可以使用以下事实：==任何正则表达式都可以直接转换为上下文无关的语法。==如果翻译了一个测试用例，使Perl的回溯在找到匹配项之前就花费了指数时间，那么翻译后的用例将使本文中的回溯解析器也需要花费指数时间来找到匹配项。

​	因此最好避免指数运行时(Exponential run time)。

### 处理二义性

​	“Yacc已死”论文正确地指出，如果要处理任意上下文无关的语法，二义性就是生活中的一个事实。上面的一个好处是，如果yacc接受您的语法，那么(因为yacc拒绝所有有二义性的与上下文无关的语法)，您就知道语法是没有二义性的。我认为这是一种非常有价值的方法，可以检查可能的语言语法，但并非所有上下文都必需。有时你不在乎，或者你知道语言是有二义性的，想要所有的可能。无论哪种方式，都可以比`指数时间解析`做得更好。 诸如CYK算法或广义LR解析之类的上下文无关的解析算法可以在 $O(n^3)$ 时间内构建一个表示所有可能解析的树。这虽然不是线性的，但也比指数好多了。

​	另一个有趣的方法来处理二义性是==完全放弃上下文无关语法==。解析表达式语法，可以有效地使用 packrat 解析，将上下文无关语法的替换 换为有序（首选项）选择，从语言中消除任何二义性并实现线性时间解析。这在某些方面与yacc采取的方法相同，但是有些人发现编写解析表达式语法比yacc语法更容易。

​	这些基本上是在上下文无关语法中处理二义性的仅有的两种方法：要么处理它(可能在多项式时间内)，要么限制可能的输入语法，以确保线性时间解析，从而消除二义性。显而易见的第三种方法——接受所有上下文无关的语法，但只识别和拒绝有二义性的语法——是一个无法确定的问题，相当于解决停机问题（halting problem）。

### 货物崇拜

​	“Yacc已死”的论文首先是严厉地批判了使用诸如 Perl 之类的（不是真的）正则表达式来解析上下文无关语言的做法，Larry Wall曾经称之为“货物崇拜解析”，原因是 ==剪切和粘贴模仿和复制“魔术”表情的发生率很高==。 该论文说，人们滥用正则表达式而不是使用 yacc 之类的工具，因为“正则表达式是‘所见即所得’——所描述的语言是匹配的语言；而解析器生成器是如果你理解了LR(k)，你看到的就是你得到的。”

为了停止“货物崇拜解析”，我们需要一个新的方法来解析：

* 处理任意上下文无关语法；
* 平均有效解析；
* 可以实现为一个库。

​	然后论文开始讨论“正则表达式衍生物的重新审视”这篇论文。我希望就像回到派生方法一样，可以更轻松地实现正则表达式匹配，并且可以以更高效的方式进行正则表达式匹配，我非常希望在上下文无关的解析中也会遇到同样的情况。相反，本文采用了正则表达式匹配中的一个经典错误——==通过指数回溯进行搜索==，因为代码更容易编写——并将其应用于上下文无关的解析。

​	具体而言，这篇论文未能实现目标2：“平均有效地解析”。大多数任意上下文无关的语法是有二义性的，并且大多数输入都是无效的，因此大多数解析在放弃并声明输入无法解析之前要花费所有时间来探索所有二义性。

​	这篇论文并没有结束所谓的“货物崇拜”解析问题，反而成为了 Richard Feynmam 所谓的“货物崇拜科学”的主要例子（Larry Wall在重复 Feynmam的说法）。 该文章模仿了一条成功的研究路线，但缺少给出高效结果的理论基础，导致了失败的结果。

​	抛开这些批评不谈，必须指出，论文中 Scala 的代码确实实现了目标1和目标3。它花费很少的精力就可以处理任意上下文无关的语法，最重要的是，它的代码非常优雅。不幸的是，在两者中使用回溯和相关的指数运行时使代码更易于学习而不是使用。

### Is yacc dead?

​	Yacc 是一个古老的工具，它具有一定的时代局限性，但是正如 Plan 9 手册评价 $lex(1)$ 所说——“杀死这个恐龙的小行星仍还在轨道上。”，即使你认为yacc本身没有使用价值（事实并非如此），提供引人注目的替代方案的新工具仍然体现了 Yacc 的精神。尽管GNU Bison可以选择生成GLR解析器而不是 LALR（1）解析器，但 Bison 仍然保留了 yacc 令人恼火的在错误消息中缺少细节的特性（lack of detail in error messages）。ANTLR是一种更全面的特性，但这种方法的采用不太广泛。 这些工具以及许多其他工具都保证，如果它们告诉您语法是没有二义性的，它们将为您提供线性时间解析器，否则，在最坏情况下，它们会提供一个三次解析器。 计算机科学理论没有更好的方法。 但是，这些方法中的任何一个都比指数时间解析器更好。

### 参考文献：

1. [Yaac is Not Dead](https://research.swtch.com/yaccalive)
2. [Yaac is Dead](https://arxiv.org/abs/1010.5023)
3. [Derivatives of Regular Expressions](https://research.swtch.com/yaccalive)




